import sass from 'node-sass';
import path from 'path';

const EXCLUDE_PATTERN = /node_modules|bower_components/;

function addDep(list, item) {
  if(list.indexOf(item) === -1) list.push(item);
}

class Audit {
  constructor(rootDir) {
    this.rootDir = rootDir;
    this.includedFiles = [];
    this.result = null;
    this.lastStartAt = null;
    this.hash = null;
  }

  isUpToDay(timestamps) {
    if(this.lastStartAt) {
      var maxTimestamp = this.includedFiles.reduce(function(acc, key) {
        if(timestamps[key] && acc < timestamps[key]) {
          return timestamps[key];
        } else {
          return acc;
        }
      }, 0);

      if(this.lastStartAt < maxTimestamp) {
        this.hash = maxTimestamp.toString();
      } else {
        this.hash = null;
        return true;
      }
    } else {
      this.hash = 'init';
    }

    return false;
  }

  track(stats) {
    this.result = {
      includedFiles: stats.includedFiles.filter(file => !EXCLUDE_PATTERN.test(file)),
      start: stats.start
    };
  }

  handle(compilation) {
    if(this.result !== null) {
      this.lastStartAt = this.result.start;
      this.includedFiles = this.result.includedFiles;
      this.result = null;
    }

    addDep(compilation.contextDependencies, this.rootDir);
    this.includedFiles.forEach(file => addDep(compilation.fileDependencies, file));
    if(this.hash && this.hash !== 'init') compilation.modifyHash(this.hash);
  }
}

const MARK = 'sass-webpack-plugin';

function toFilename(originFile) {
  return path.basename(originFile).replace(/(scss|sass)$/i, 'css');
}

function toAsset(result) {
  return {
    map: () => result.map,
    source: () => result.css,
    size: () => result.css.byteLength
  };
}

function wrapError(err) {
  var header = MARK;
  if(err.file && err.line) {
    header = `${header} ${err.file}:${err.line}`;
  }
  return new Error(`${header}\n\n${err.message}\n`);
}

class SassPlugin {
  constructor(file, mode, custom) {
    var options = {};

    if(mode === 'development' || mode === undefined) {
      options = {
        indentedSyntax: true,
        indentWidth: 2,
        sourceMap: true,
        sourceMapEmbed: true,
        sourceComments: true,
        sourceMapContents: true
      };
    } else if(mode === 'production') {
      options = { outputStyle: 'compressed' };
    } else if(typeof mode === 'object') {
      options = mode;
    }

    if(typeof custom === 'object') {
      options = Object.assign(options, custom);
    }
    options.file = path.resolve(file);
    this.options = options;
  }

  apply(compiler) {
    let options = this.options;
    let fileName = toFilename(options.file);
    let audit = new Audit(path.dirname(options.file));
    let chunk;

    compiler.plugin('compilation', (compilation) => {
      // skip child compilers
      if(compilation.compiler !== compiler) return;

      chunk = compilation.addChunk(MARK);
      chunk.ids = [];
      if(chunk.files.indexOf(fileName) === -1) chunk.files.push(fileName);

      if(audit.isUpToDay(compilation.fileTimestamps)) return;

      compilation.plugin('additional-assets', (cb) => {
        sass.render(options, (err, result) => {
          if(err) {
            compilation.errors.push(wrapError(err));
          } else {
            compilation.assets[options.outFile || fileName] = toAsset(result);
            audit.track(result.stats);
          }
          cb();
        });
      });
    });

    compiler.plugin('emit', (compilation, cb) => {
      let mainModule = compilation.modules[0];
      chunk.addModule(mainModule);
      mainModule.addChunk(chunk);
      compilation.chunks.push(chunk);
      cb();
    });

    compiler.plugin('after-emit', (compilation, cb) => {
      audit.handle(compilation);
      cb();
    });
  }
}

export default SassPlugin;
